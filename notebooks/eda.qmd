---
title: HuggingFace Explo
jupyter: python3
format:
    html:
        code-fold: false
---

# Load modules and data

```{python}
# Standard library imports
import re
from collections import Counter

# Third-party library imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sn
from datasets import load_dataset
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.decomposition import PCA
from datasets import load_dataset

# Local application/library imports
from chordal_wip.chordcleaner import ChordCleaner
```

## Load HuggingFace ds and select a genre

```{python}
ds = load_dataset("lluccardoner/melodyGPT-song-chords-text-1")
ds = ds['train'].to_pandas()

# Filter by pop
ds_pop = ds[ds['genres'].str.contains('pop', case=False)].reset_index()
ds_pop = ds_pop[ds_pop["chords_str"].notna()]

# Make set smaller since my funcs are probably not super efficient
ds_pop = ds_pop.iloc[2843]
#ds_pop.to_csv("test.csv")
ds_pop.head()
```

## Use ChordCleaner

```{python}
cc = ChordCleaner(threshold = 3)

print(ds_pop[["chords_str"]])
ds_pop["chords_str_clean"] = cc.clean(ds_pop["chords_str"])
```

## Do some eda

```{python}
# Stats about chord progression length
ds_pop["chord_count"] = ds_pop["chords_str_clean"].apply(lambda x: len(x.split()))
print(f"Descriptive stats about chord progression length:\n {ds_pop["chord_count"].describe()}")
print("\n\n")

# Common chords
all_chords = ds_pop["chords_str_clean"].str.split().explode()
print(f"Top 20 common chords: \n{all_chords.value_counts().head(10)}")

print("\n\n")
print(f"Top 20 least common chords: \n{all_chords.value_counts().tail(10)}")
print("These should not totally weird!")
```

## Plot common chords (top n)

```{python}

pop_counts = ds_pop["chords_str_clean"].str.split(" ").explode().value_counts()
n = 50
pop_counts.head(50).plot(
    kind='bar',
    figsize=(50, 4),
    title='Chord Frequency Histogram'
)
```

## Chord transition pattern

```{python}
# Create chord transitions
transitions = []
for progression in ds_pop["chords_str_clean"]:
    chords = progression.split()
    transitions.extend(list(zip(chords[:-1], chords[1:])))

# Count transitions
transition_counts = Counter(transitions)
print(transition_counts.most_common(20))  # Top 20 transitions

```

## Transition matrix

This should be mapped to roman numeral notation, i.e. root-independent.

```{python}
#| eval: false
 
# Encode chords as integers
chords = ds_pop["chords_str_clean"].str.split().explode()
le = LabelEncoder()
chords_encoded = le.fit_transform(chords)

# Build transition matrix
n_chords = len(le.classes_)
transition_matrix = np.zeros((n_chords, n_chords))

for progression in ds_pop["chords_str_clean"]:
    chords = progression.split()
    encoded = le.transform(chords)
    for i in range(len(encoded) - 1):
        transition_matrix[encoded[i], encoded[i + 1]] += 1

# Normalize to probabilities
transition_matrix = transition_matrix / transition_matrix.sum(axis=1, keepdims=True)

sn.heatmap(transition_matrix, xticklabels=le.classes_, yticklabels=le.classes_)
plt.title("Pop Chord Transition Matrix")
plt.show()
```

## PCA

```{python}
#| eval: false
# Create the document-term matrix
chord_matrix = pd.get_dummies(all_chords).groupby(level=0).sum()

# Check the shape of the chord matrix
print(f"Shape of the chord matrix: {chord_matrix.shape}")

# Standardize the data
scaler = StandardScaler()
chord_matrix_scaled = scaler.fit_transform(chord_matrix)

# Perform PCA
pca = PCA(n_components=2)
pca_result = pca.fit_transform(chord_matrix_scaled)

# Create a DataFrame for the PCA results
pca_df = pd.DataFrame(data=pca_result, columns=['PC1', 'PC2'])
pca_df['Chord'] = chord_matrix.index

# Visualize the PCA results
plt.figure(figsize=(10, 6))
plt.scatter(pca_df['PC1'], pca_df['PC2'])
for i, txt in enumerate(pca_df['Chord']):
    plt.annotate(txt, (pca_df['PC1'][i], pca_df['PC2'][i]), fontsize=8)

plt.title('PCA of Chords')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid()
plt.show()
```

```{python}
#| eval: false
# Does this LLM-code do what I want?
pca_df['genres'] = ds_pop["genres"]

plt.figure(figsize=(12, 8))
sn.scatterplot(data=pca_df, x='PC1', y='PC2', hue='genres', style='genres', palette='deep')

plt.title('PCA of Chords Grouped by Genre')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()
```
